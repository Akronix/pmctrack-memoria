\chapter{libpmctrack}
\begin{resumen}
Una parte transcendental del proyecto ha sido la implementación de una librería llamada \textbf{libpmctrack}, que provee a los programadores de la funcionalidad de monitorización que brinda PMCTrack. De esta forma, un programador puede obtener información de cómo se comporta el hardware mientras se está ejecutando su programa haciendo simplemente llamadas a la API de libpmctrack, e incluso hacer uso de dicha información para otras funciones más allá de la pura monitorización.
\end{resumen}

\section{Motivación}

Mientras que la herramienta de línea de comandos \texttt{pmctrack} hace una gran labor para monitorizar el comportamiento global de un programa dado, carece de la posibilidad de permitir monitorizar líneas específicas de código.

\section{Descripción libpmctrack}

libpmctrack es una librería escrita en C, al igual que el resto de los componentes de PMCTrack, y que encapsula las funcionalidades de monitorización que tiene PMCTrack en una API de funciones disponibles al programador. De este modo, libpmctrack proporciona al programador del acceso directo a la información obtenida desde los \ac{PMC}, sin tener que preocuparse de la implementación de dichos contadores en cada arquitectura. Además, libpmctrack permite el uso de los \glosstex{contadores virtuales} proveídos por los módulos de PMCTrack para cada arquitectura, lo cual es una gran ventaja frente a otras herramientas con fines similares como PAPI-C \cite{papiC}.

La función más evidente que permite esta librería es hacer observaciones del rendimiento, ya sea de un programa software que hayamos escrito; o ya la de uno o varios procesadores hardware para un cierto código software dado. Pero además...blabla

La implementación interna de la librería difiere ligeramente del usado para la herramienta de línea de comandos PMCTrack. En este caso, no se trata de un proceso padre que se encarga de lanzar y monitorizar un proceso hijo; si no de un proceso que, mediante llamadas a la librería libpmctrack, obtiene sus propios datos de monitorización de los \ac{PMC} y es el programador quién debe decidir qué hacer con estos datos de retorno. Este modo de uso permite que los programas sean capaces incluso de tomar decisiones en tiempo de ejecución según los datos hardware que estén obteniendo.

Para usar esta librería, el programador solo tiene que incluir nuestra librería libpmctrack, configurar qué monitorizar y encerrar el código que quiera monitorizar con llamadas a las funciones \texttt{pmctrack\_start\_count()} y \texttt{pmctrack\_stop\_count()}.
La configuración para la monitorización se hace pasando un string con la configuración para cada \ac{PMC} o contador hardware y, opcionalmente, los \glosstex{contadores virtuales} que se quieren utilizar.

La libpmctrack también soporta la monitorización de programas \textit{multithreading}. Para permitir que fragmentos de código independientes sean monitorizados de manera simultánea, el módulo del kernel de PMCTrack mantiene un buffer separado para cada uno de los hilos. Esta propiedad es especialmente interesante en entornos de programación paralela.\\
Por ejemplo OpenMP o Cilk, aplican el \glosstex{patrón de diseño} \textit{fork-join}, donde se divide el problema en subtareas, se crea un nuevo hilo para solucionar cada una de las subtareas y se rejuntan de nuevo una vez que cada una ha terminado su subtarea. Con libpmctrack se podría evaluar que desempeño tiene cada uno de los los hilos creados de esta manera y averiguar el umbral a partir del cual conviene dividir una tarea en dos subtareas más pequeñas.

\section{Refactorización \texttt{pmctrack} usando libpmctrack}
Durante el transcurso del proyecto, y con la librería casi acabada, nos dimos cuenta de que había mucho código repetido entre ésta y la herramienta de comandos \texttt{pmctrack}. Fue entonces cuando pensamos que podríamos hacer uso de las funciones de la librería desde \texttt{pmctrack}. Hicimos, por tanto, una refactorización del código de \texttt{pmctrack}, haciendo llamadas a las funciones las cuales ya disponíamos en libpmctrack.

En la refactorización, nos fijamos el objetivo de conseguir que \texttt{pmctrack} no se tuviese que comunicar directamente con el kernel en ningún momento, y se limitase a tener código únicamente sobre la interacción con el usuario, la creación de los procesos y estructuras para monitorizar, y las llamadas a las funciones de libpmctrack que hicieran el trabajo de bajo nivel.

Gracias a esta refactorización, hemos conseguido reducir el código de \texttt{pmctrack} sustancialmente: inicialmente el código era de casi 900 líneas de código y después el código ha quedado a algo más de 500, en total una disminución del 40\%. Asímismo, el código ha quedado más desacoplado de la parte interna de PMCTrack, mejorando así notablemente en cuanto a claridad y sencillez.

La refactorización también influyó positivamente en la librería, puesto que nos sirvió para verificar su funcionamiento y depurarla. Además, añadimos algunas funciones nuevas a la librería, que resultaron ser más relevantes tener en ésta en lugar de directamente desde el código del programa que la usase.

\section{API}
La API está separada en dos interfaces.\\
La primera viene definida en el fichero \texttt{pmctrack.h} y en ella se proveen las funciones de alto nivel que se necesitan para un uso estándar de monitorización de un programa dentro del propio código.\\
La segunda viene definida en el fichero \texttt{pmctrack\_internal.h} y contiene otra serie de funciones para acceso de más bajo nivel a las funcionalidades que provee el kernel modificado para PMCTrack. Es este segunda interfaz la que usa el programa de línea de comandos.

Pasamos a desarrollar cada una de ellas individualmente.

\subsection{pmctrack.h}
Como hemos dicho anteriormente, pmctrack.h correspondería a la interfaz básica para monitorizar rendimiento desde el código fuente.

El fichero pmctrack.h define un struct para usar en el paso de opciones a las funciones y también las funciones estándar de la API para libpmctrack. Todas estas funciones comienzan con el prefijo \texttt{pmctrack\_*}. El código de este fichero cabecera puede verse en la figura \ref{fig:pmctrackh}. A continuación, pasamos a explicar brevemente cada función.

\begin{figure}[!h]
\caption{Interfaz básica libpmctrack}
\label{fig:pmctrackh}
\begin{lstlisting}[frame=single,language=C]
typedef struct {
	/* File descriptors */
	int fd_monitor;
	/* Buffer (pre-allocated) */
	pmc_sample_t* samples;
	unsigned int pmcmask;
	unsigned int kern_pmcmask;
	unsigned int nr_pmcs;
	unsigned int nr_virtual_counters;
	unsigned int virtual_mask;
	unsigned int nr_experiments; // Multiplexation...
	unsigned int ebs_on;
	unsigned int nr_samples;
	unsigned int max_nr_samples;
}pmctrack_desc_t;

/* Connect with the performance tool */
int pmctrack_init(pmctrack_desc_t* desc, unsigned max_nr_samples);
int pmctrack_destroy(pmctrack_desc_t* desc);
int pmctrack_clone_descriptor(pmctrack_desc_t* dest, pmctrack_desc_t* orig);
int pmctrack_config_counters(pmctrack_desc_t* desc, char* strcfg[], char* virtcfg, int mux_timeout_ms);
int pmctrack_start_counters(pmctrack_desc_t* desc);
int pmctrack_stop_counters(pmctrack_desc_t* desc);
void pmctrack_print_counts(pmctrack_desc_t* desc, FILE* outfile, int extended_output);
\end{lstlisting}
\end{figure}

El struct \texttt{pmctrack\_desc\_t} no se debe modificar directamente por el usuario y sirve para que libpmctrack deposite allí la configuración de monitorización a realizar. De este modo se consigue de una forma elegante, sencilla y transparente al usuario el paso de parámetros y de valores entre funciones de libpmctrack. Los diversos campos, por tanto, corresponden a valores de configuración y de resultados de monitorización obtenidos por libpmctrack.

Para usar esta librería, el usuario lo primero que tendrá que hacer es declarar un \texttt{struct pmctrack\_desc\_t} y hacer que libpmctrack lo inicialice llamando a \texttt{pmctrack_init()} junto con un número máximo de muestras para definir un tamaño máximo al buffer intermedio que los va a ir almacenando.

A continuación, se ha de definir los strings con la definición de los contadores que se quieren usar y los eventos que se quiere que se cuenten, asícomo con los contadores virtuales si se quisiese usar alguno. Estos strings se han de pasar como argumento a la función \texttt{pmctrack_config_counters()}.

Ahora ya podemos rodear las partes de código que queramos monitorizar comenzando con \texttt{pmctrack_start_counters()} y acabando con \texttt{pmctrack_stop_counters()}. Obsérvese que se puede llamar multiples veces a estas dos funciones mientras el máximo de muestras no se vaya a superar. Si se superase dicho tamaño no habría ningún error en ejecución del programa pero sí se perderían algunos datos.

Los datos leídos de esta manera se habran guardado en el campo \texttt{samples}. Para pedirle a libpmctrack que itere sobre ellos y nos los muestre debemos usar la función \texttt{pmctrack_print_counts()}, que nos los escribirá en el fichero que le pasemos como argumento. El valor \texttt{extended_output} es un booleano con el cual indicamos si queremos la información básica o queremos también información más avanzada como el id del experimento mostrandose o el core del cual se ha extraído la muestra.

Finalmente, la función \texttt{pmctrack\_destroy()} cerrará los ficheros que quedasen abiertos y liberará la memoria reservada para el buffer.

\subsection{pmctrack_internal.h}
La interfaz pmctrack_internal.h corresponde a una interfaz más avanzada puesto que permite usar las funciones de las que provee el kernel modificado con pmctrack, de forma que la abstracción en esta interfaz para el usuario es mucho menor.

Así pues, ahora tenemos el fichero pmctrack_internal.h que provee de nuevas funciones, todas ellas precedidas por la palabra \texttt{pmct_*}. Además, incluye al fichero \texttt{pmctrack.h} con lo cual basta con incluir la interfaz internal para tener toda la API de libpmctrack. El código de este fichero cabecera puede verse en la figura \ref{fig:pmctrackinternalh}. Igual que con la interfaz anterior, explicamos brevemente cada función.

\begin{figure}[!h]
\caption{Interfaz avanzada libpmctrack}
\label{fig:pmctrackinternalh}
\begin{lstlisting}[frame=single,language=C]
int pmct_check_counter_config(char* userpmccfg[],
                              unsigned int* nr_counters,
                              unsigned int* counter_mask,
                              unsigned int* ebs,
                              unsigned int* nr_experiments);
int pmct_check_vcounter_config(char* virtcfg, unsigned int* nr_virtual_counters, unsigned int* virtual_mask);
int pmct_config_counters(char* strcfg[]);
int pmct_config_virtual_counters(char* virtcfg);
int pmct_config_timeout(int msecs, int kernel_control);
int pmct_start_counting( void );
void pmct_print_header (FILE* fo, unsigned nr_experiments,
                        unsigned pmcmask,
                        unsigned virtual_mask,
                        int extended_output);
void pmct_print_sample (FILE* fo, unsigned nr_experiments,
                        unsigned pmcmask,
                        unsigned virtual_mask,
                        unsigned extended_output,
                        int nsample,
                        pmc_sample_t* sample);
int pmct_attach_process (pid_t pid);
int pmct_open_monitor_entry(void);
int pmct_read_samples (int fd, pmc_sample_t* samples, int max_samples);
\end{lstlisting}
\end{figure}

\begin{description}
  \item[pmct_check_counter_config()] \hfill \\
  Comprueba que el string de configuración para los \ac{PMC} y para ebs es correcto, y devuelve los valores que haya extraído así en: \texttt{nr_counters, counter_mask, ebs, nr_experiments.}. En caso de que no se le pasase un string de configuración, esta función permite obtener dichos valores de configuración del fichero /proc/pmc/properties.

  \item[pmct_check_vcounter_config()] \hfill \\
  Comprueba que el string de configuración para contadores virtuales es válido y devuelve los valores extraídos en: \texttt{virtual_mask y nr_virtual_counters}.

  \item[pmct_config_counters()] \hfill \\
  Dado un string de configuración, registra directamente en la entrada /proc/pmc/config, la cual usará el kernel para saber cómo tiene que configurar la monitorización. Imprescindible para poder monitorizar un proceso.

  \item[pmct_config_virtual_counters()] \hfill \\
  Similar al anterior, registra la configuración de los contadores virtuales pasada como párametro en la entrada /proc/pmc/config.

  \item[pmct_config_timeout()] \hfill \\
  Registra los valores de tiempo en la entrada /proc/pmc/config.

  \item[pmct_start_counting()] \hfill \\
  Avisa al kernel de que se quiere empezar la monitorización.

  \item[pmct_print_header()] \hfill \\
  Escribe \"una cabecera\" con las columnas correspondientes a la configuración pasada por parámetro.

  \item[pmct_print_sample()] \hfill \\
  Dado un \textit{sample}, escribe las muestras obtenidas para cada \ac{PMC} y contador virtual configurado.

  \item[pmct_attach_process()] \hfill \\
  Registra el pid pasado como argumento para que se monitorice el proceso con ese pid.

  \item[pmct_open_monitor_entry()] \hfill \\
  Abre fichero /proc/pmc/monitor para lectura. Necesario hacerlo si se quiere empezar a configurar una monitorización.

  \item[pmct_read_samples()] \hfill \\
  Lee el máximo de muestras ---o hasta la máxima capacidad del buffer si no se ha definido un máximo--- desde el fichero pasado como argumento. Las muestras se devuelven en el parámetro \texttt{samples} y el número de muestras leídas es el valor de retorno de la función.

\end{description}

\section{Caso de estudio}
% añadir ejemplos de uso de pmctrack.h con mis dos heaps: williams y fibonacci

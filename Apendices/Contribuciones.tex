%---------------------------------------------------------------------
%
%                          Apéndice Contribuciones
%            Al menos dos páginas de qué ha hecho cada uno.
%
%---------------------------------------------------------------------

\chapter{Contribuciones de cada participante}
\label{app:contribuciones}

En este apéndice cada participante indicará su contribución al proyecto en su respectiva sección.

\section{Contribución de Jorge Casas Hernán}

La mayoría de mi contribución a este proyecto ha estado dirigida a la aplicación PMCTrack-GUI, de la cual he implementado desde el sistema de ventanas con el cual interactúa el usuario hasta la generación de las gráficas en tiempo real con el uso de la librería _matplotlib_, pasando por el diseño e implementación de componentes internos de la aplicación. No obstante, también he colaborado en la realización de la extensión de PMCTrack para el soporte de aplicaciones multihilo desde el espacio de usuario, extensión que hemos desarrollado de forma conjunta mi compañero de proyecto y yo. En el resto de líneas de esta sección profundizo en detalle en cada uno de estos aspectos.

La primera etapa productiva que realicé en este proyecto fue el estudio de documentación acerca del lenguaje Python, lenguaje que elegimos para el desarrollo de PMCTrack-GUI, por los motivos explicados en la sección AAA. Esta tarea de estudio de documentación comprendió no solo el propio lenguaje de programación básico, si no también las librerías WxPython y Matplotlib que serían usadas ampliamente en la implementación de la aplicación. A lo largo de esta etapa realicé pequeñas aproximaciones a funcionalidades concretas con las que tenía que contar PMCTrack-GUI, para familiarizarme con el lenguaje.

Una vez entendido el funcionamiento básico de Python y sus librerías, comencé a desarrollar las primeras ventanas de configuración del usuario, basadas en los bocetos que habíamos realizado previamente. A medida que implementaba cada una de estas ventanas iba conociendo más en profundidad la librería WX y el lenguaje Python en general. Esto me permitió reimplementar las ventanas realizando una serie de optimizaciones que mejoraron ampliamente el aspecto final de la aplicación.

\clearpage

\section{Contribución de Abel Serrano Juste}

De entre los dos miembros del grupo, yo he sido el encargado de especializarme en la parte de más bajo nivel del proyecto. En particular, esto comprendía, entre otros, la lectura de documentación sobre contadores hardware, el estudio profundo de la herramienta PMCTrack, el desarrollo y refactorización del código con libpmctrack, el soporte de los eventos de bajo nivel para la interfaz gráfica,\ldots

En las siguientes subsecciones desarrollaré de forma más detallada mis contribuciones, agrupándolas en las siguientes puntos:
\begin{enumerate}
  \item Estudio de documentación
  \item Participación en el diseño de PMCTrack-GUI
  \item Implementación de los objetos de procesamiento para PMCTrack-GUI
  \item Implementación conjunta del soporte \textit{multithreading} en PMCTrack
  \item Diseño e implementación de libpmtrack. Refactorización de \texttt{pmctrack}
  \item Realización de los benchmarks para el caso de estudio de libpmctrack
\end{enumerate}

Dichos puntos no están ordenados de forma estrictamente cronológica, puesto que bastante del trabajo contenido en ellos se realizó de forma intermitente o solapada con el trabajo de otros puntos.

\subsection{Estudio de documentación}

El estudio de documentación estuvo presente a lo largo de todo el proyecto; puesto que éste constó del trabajo a muy distintos niveles y con diferentes tecnologías.

En un primer momento, la documentación que estudié fue la relativa a familiarizarme con la monitorización mediante contadores hardware o PMCs y con la herramienta PMCTrack.\newline
Comencé con la lectura de la memoria del proyecto precedente al nuestro, del año 2012, dónde se introducía por primera vez la herramienta PMCTrack. A continuación, leí más documentación acerca de herramientas que cumplían funcionalidades parecidas a las de PMCTrack, como OProfile y perf. Adicionalmente, forma parte de esta primera fase de documentación, la lectura de los diversos manuales para desarrolladores de los distintos fabricantes de microprocesadores: AMD, Intel y ARM. En estos manuales, se presenta información muy detallada y particular de cómo usar los PMC para cada fabricante, junto con los códigos y la descripción de cada uno de los eventos que éstos pueden monitorizar.

En lo que podríamos llamar una segunda fase del estudio de documentación, me dediqué al aprendizaje del lenguaje de programación Python. Para ello, me leí un tutorial de Python 2.7 y realicé un pequeño curso online gratuito facilitado por Google. Esta fase se corresponde con la implementación de los objetos de procesamiento para PMCTrack-GUI, apartado \ref{app:contr-abel-objs} de este apéndice.

Por último, la última fase de mi estudio de documentación se corresponde con las contribuciones de más bajo nivel: ``Implementación conjunta del soporte \textit{multithreading}'' y ``Diseño e implementación de libpmtrack'', apartados \ref{app:contr-abel-mult} y \ref{app:contr-abel-lib} respectivamente.\newline
En esta fase, la documentación fue sobre todo alrededor de la lectura del código C que existía previamente en la herramienta PMCTrack, incluyendo los relativos al kernel Linux modificado, a los módulos para el kernel y a la herramienta de línea de comandos \texttt{pmctrack}.

\subsection{Participación en el diseño de PMCTrack-GUI}

En la etapa de realización de bocetos de la interfaz para PMCTrack-GUI, realicé varios de los bocetos sobre los que discutimos para llegar al diseño final de la interfaz. Dichos bocetos los realicé mediante la herramienta \textit{Balsamiq Mockups}, cuyo uso había aprendido en la asignatura ``Diseño de Sistemas Interactivos'' en el primer semestre de este curso.
Los bocetos fueron al principio de baja fidelidad, y, fueron aumentando su nivel de fidelidad y detalle según fuimos discutiendo e iterando en el proceso de diseño.\newline
Por supuesto, también participé en las reuniones que tuvimos para el debate de estos bocetos.

\subsection{Implementación de los objetos de procesamiento para PMCTrack-GUI}
\label{app:contr-abel-objs}

Inicialmente para el desarrollo de PMCTrack-GUI hicimos una división del trabajo. Yo me encargaba de la parte que más tendría que ver con las cuestiones a bajo nivel, tales como la encapsulación de la información relevante de la máquina en un objeto Python o la modelización de los eventos hardware que pueden contar los PMCs; mientras que Jorge se encargaba de la implementación de los componentes gráficos con wxPython según los diseños realizados en la fase anterior.

Para realizar esta tarea, comencé haciendo un diagrama UML inicial. Debatimos e iteramos repetidas veces sobre ese diagrama.
El diseño final al que llegamos consiste, principalmente, en una interfaz fachada para comunicarse con el resto de la interfaz gráfica y de varias clases para encapsular los eventos y la información de la máquina que se quiere monitorizar.\newline
Además, necesitaba guardar de forma persistente los datos relativos a los eventos de cada modelo y a la configuración de los contadores de cada fabricante, de modo que elegí entre varias opciones la de usar ficheros XML por su sencillez de editar y su claridad en su lectura.

Así pues, mi contribución en esta parte del proyecto fue la implementación en Python de todo lo expuesto en el párrafo anterior, junto con el \textit{parser} para los ficheros XML. Además de esto, también realicé los ficheros DTD que servirían para verificar la correctitud de los ficheros XML, escribí algunos ficheros XML a mano y programé el script en Bash encargado de generar el resto de archivos XML a partir de sus correspondientes archivos CSV.

\subsection{Implementación conjunta del soporte \textit{multithreading}}
\label{app:contr-abel-mult}

Para la implementación del soporte multithreading en el kernel de PMCTrack, fue necesario primero un cuidadoso estudio de cómo funcionaba la herramienta anteriormente. Después de este estudio, tuvimos una reunión en la que discutimos varias posibilidades hasta dar con un diseño adecuado para conseguir una buena solución al problema.

Con este diseño ya planteado, Jorge y yo realizamos diversas jornadas de trabajo conjuntas para la implementación completa de esta parte del proyecto. Posteriormente, realizamos un conjunto de pruebas mediante la herramienta \texttt{pmctrack}, usando benchmarks multihilo de la suite PARSEC y contrastamos sus resultados con otras fuentes para verificar si eran correctas. Posteriormente estos son los benchmarks que usaríamos para el caso de estudio del soporte multihilo en PMCTrack, comentados detalladamente en la sección \ref{sec:case-multithreading} de este documento.

\subsection[Diseño e implementación de libpmtrack]{Diseño e implementación de libpmtrack.\newline
Refactorización de \texttt{pmctrack}
}
\label{app:contr-abel-lib}

Para el diseño de la librería libpmctrack tuvimos varias reuniones conjuntas en las que decidimos las funciones que constituirían la interfaz básica y la interfaz avanzada.
Con las interfaces ya definidas, yo fuí el encargado de implementar todas estas funciones en lenguaje de programación C.

Con la implementación de la librería casi terminada, nos dimos cuenta que había mucho código repetido y que se podría hacer que \texttt{pmctrack} hiciera uso de la librería en lugar de acceder directamente a PMCTrack. De modo que corrió a mi cargo también la refactorización del código de la herramienta \texttt{pmctrack} para que hiciese solamente llamadas a la librería en lugar de comunicarse directamente con el kernel.

% Versión inicial de este apéndice (por Abel):
%  Para el diseño de la librería libpmctrack, primero tuvimos una reunión conjunta en la que pensamos las funciones que tendría que tener la API para que un usuario pudiera monitorizar su código de forma sencilla.
%  Después de una temporada de trabajo durante la cual estuve implementando dicha API, tuvimos una segunda reunión en la que pensamos en añadir funciones más avanzadas que permitieran la comunicación directa con el kernel de PMCTrack. Para separar estas funciones de las anteriores, decidimos crear una segunda API o interfaz de C, con las cabeceras de las funciones que permitían un nivel de abstracción más bajo.

\subsection{Realización de los benchmarks para el caso de estudio de libpmctrack}

Para el caso de estudio de libpmctrack ---comentado en la sección \ref{sec:case-libpmctrack} de esta memoria--- adapté unas implementaciones mías en C++ de las estructuras de datos \textit{binary heap} y \textit{Fibonacci heap}.

Finalmente, también programé los benchmarks en C++ que usamos en dicho caso de estudio para los diversos análisis.
